<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 仲夏园</title><link>https://goplscn.github.io/post/</link><description>Recent content in Posts on 仲夏园</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Aug 2020 14:51:05 +0000</lastBuildDate><atom:link href="https://goplscn.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>MockServer 简介</title><link>https://goplscn.github.io/post/mockserver-intro/</link><pubDate>Wed, 26 Aug 2020 14:51:05 +0000</pubDate><guid>https://goplscn.github.io/post/mockserver-intro/</guid><description>MockServer简介 服务端测试中，被测服务通常依赖于一系列的外部模块，被测服务与外部模块间通过REST API调用来进行通信。要对被测服务进行系统测试，一般做法是，部署好所有外部依赖模块，由被测服务直接调用。然而有时被调用模块尚未开发完成，或者调用返回不好构造，这将影响被测系统的测试进度。为此我们需要开发桩模块，用来模拟被调用模块的行为。最简单的方式是，对于每个外部模块依赖，都创建一套桩模块。然而这样的话，桩模块服务将非常零散，不便于管理。Mock Server为解决这些问题而生，其提供配置request及相应response方式来实现通用桩服务。本文将专门针对REST API来进行介绍Mock Server的整体结构及应用案例。
{% asset_img 311516-20170912180553860-879452344.png %}
MockServer支持能力 1. 返回“模拟”响应 {% asset_img expectation_response_action.png Title:&amp;quot;Response Action Expectation&amp;quot; %}
2. 执行回调，动态创建响应 {% asset_img expectation_callback_action.png Title:&amp;quot;Callback Action Expectation&amp;quot; %}
3. 返回异常或无效响应 {% asset_img expectation_error_action.png Title:&amp;quot;Error Action Expectation&amp;quot; %}
MockServer支持匹配规则 请求属性匹配器使用以下一个或多个属性匹配请求： method-属性匹配器 path-属性匹配器 path parameters-多个值匹配器的键 query string parameters-多个值匹配器的键 headers-多个值匹配器的键 cookies-单个值匹配器的关键 body-请求体匹配器 secure- 布尔值，为 true 时 使用 HTTPS。 属性匹配可以使用： 字符串值 用于：方法、路径、路径参数键、路径参数值、查询参数键、查询参数值、标头键、标头值、Cookie 键、Cookie 值或实体 示例：方法、路径、路径参数、查询参数、标头、cookie 正则表达式值 用于：方法、路径、路径参数键、路径参数值、查询参数键、查询参数值、标头键、标头值、Cookie 键、Cookie 值或实体 示例：方法、路径、路径参数、查询参数、标头 有关语法，请参阅Java 正则表达式语法 json schema 用于：方法、路径、路径参数值、查询参数值、标头值、Cookie 值或实体 不支持：路径参数键、查询参数键、标头键或 Cookie 键 示例：路径参数、查询参数、标头、cookie 有关语法，请参阅JSON Schema文档 可选值 用于： 方法、路径、路径参数值、查询参数键、查询参数值、标头键、标头值、Cookie 键、Cookie 值或实体 不支持：路径参数键或值、查询参数值、标头值或 Cookie 值 示例：查询参数、标头、cookie 否定值 用于：方法、路径、路径参数键、路径参数值、查询参数键、查询参数值、标头键、标头值、Cookie 键、Cookie 值或实体 示例：方法、路径、标头 匹配多个值的键支持标头、查询参数和路径参数的每个键的多个值</description></item><item><title>按测试员的方式思考</title><link>https://goplscn.github.io/post/think-like-a-tester/</link><pubDate>Wed, 01 Jul 2020 16:32:58 +0000</pubDate><guid>https://goplscn.github.io/post/think-like-a-tester/</guid><description>测试员有很多不同的背景，测试团队是多元化的集体，但是大多数人都同意：测试员的思考方式是不同的。怎么不同？有人说测试员是“消极”思维者。测试员会抱怨这种说法，认为自己喜欢征服，他们在报告坏消息时有一种特别的兴奋感。这是一种普遍观点。我们提出另一种观点。测试员并不抱怨，他们提供的是证据。测试员并不喜欢征服，他们喜欢打破产品没有问题的幻觉。测试员并不喜欢发布坏消息，他们喜欢把客户从虚假信念中解放出来。我们的观点是，按测试员的方式思考意味着实践认识论。测试运用的是认识论，不是靠傲慢或谦卑。
测试运用的是认识论 认识论研究如何认识所了解的东西：研究证据和推理。这是科学实践的基础。研究认识论的人有科学家、教育家和哲学家，当然还有精英级的软件测试员。学习认识论的学生研究科学、哲学和心理学，目标是了解怎样才能改进我们的思维。我们使用的术语比经典定义要宽，以便能够更多地利用批判性思维的最新成果。将认识论运用于软件测试，要问与以下类似的问题：
怎么知道软件足够好？ 如果软件并不是足够好，怎样才能知道？ 怎么知道已经完成了足够的测试？ 研究认识论有助于更好测试 直接与软件测试有关的认识论问题包括：
如何收集和评估证据。 如何进行有效的推论。 如何使用不同逻辑形式。 拥有合理的信念意味着什么。 形式和非形式推理之间的差别。 非形式推理的常见谬误。 自然语言的含义与模糊性。 如何做出好的决策。 研究认识论可帮助测试员设计有效的测试策略，更好地意识到自己工作中的错误，理解自己的测试能够证明什么、不能证明什么，并编写出无懈可击的测试报告。
认知心理学是测试的基础 如果说认识论告诉我们的是应该怎样思考，那么认知心理学告诉我们的是我们是怎样思考的。与测试有关的一些问题包括：
人的感觉和记忆可靠性。 信念从哪里来。 信念如何影响人的行为。 做出决策所使用的偏见和捷径。 如何了解并分享所知道的信息。 如何考虑复杂事情。 如何识别模式。 如何把想法和实物分类。 如何注意事物之间的差别。 记忆事件中的失真。 如何重新构建部分记忆的事件（例如不可再现的程序错误）。 研究认知心理学有助于理解影响测试员工作成绩的因素，以及影响人们解释自己工作方式的因素。测试应该使用因果关系理论进行系统推理，而不只是查看外部行为，并对照简单的预期描述进行检查。
测试需要推断，并不只是做输出与预期结果的比较 流行的观点认为，测试员只是执行测试用例，并对照预期结果比较执行结果。这种观点把测试看做是简单的比较活动，没有看到一些聪明人必须设计测试，并确定预期输出。想想看，测试设计人员几乎从来没有得到过应该测试什么的权威指导，更不要说应该期望什么了。可以得到的指导是要解释的主体。在现实生活中，大多数测试设计都是基于推断，或基于与测试员的推断有关的经验。不仅如此，这些推断还要随时间发生变化。像测试员那样思考，就是要掌握探索式推断的艺术。
探索式推断听起来可能像是奇怪的想法，这意味着要以一种不能事先预测的方式，通过一种思想引出另一种思想，然后再引出下一种思想。
优秀测试员会进行技术性、创造性、批判性和实用性地思考 各种类型的思考都要考虑测试的实施。但是我们认为需要提出四种主要思考：
技术性思考。对技术建模并理解因果关系的能力。这包括诸如相关技术事实的知识和使用工具并预测系统行为的能力。 创造性思考。产生思想并看到可能性的能力。测试员只能以能够想象得到的方式进行测试，只能寻找猜想会存在的问题。 批判性思考。评估思想并进行推断的能力。这包括在自己的思考中发现并消除错误的能力，将产品观察与质量准则关联起来的能力，以及针对特定信念或所建议的行动过程构建有说服力的测试用例的能力。 实用性思考。把想法付诸实践的能力。这种能力包括诸如运用测试工具，并使测试手段和力量与项目范围适应的技能。 总之，像测试员那样思考，会最终导致相信事物可能不像外表看起来那样。不管事物是怎样的，都可能有差别。我们发现，当测试过程以最具破坏性的方式失败时，根本原因最有可能是视野狭窄。换句话说，这不是运行了一万个测试，而本来应该运行一万零一个的问题；问题是没有想象出测试的总体大纲，没有做就算有两倍时间和资源也不会做的测试。
黑盒测试并不是基于无知的测试 黑盒测试意味着产品内部知识在测试中不起重要作用。大多数测试员都是黑盒测试员。为了做好黑盒测试就要了解用户，了解他们的期望和需要，了解技术，了解软件运行环境的配置，了解这个软件要与之交互的其他软件，了解软件必须管理的数据，了解开发过程，等等。黑盒测试的优势在于测试员可能与程序员的思考不同，因此有可能预测出程序员所遗漏的风险。
黑盒测试强调有关软件的用户和环境知识，这一点并不是所有人都喜欢的。我们甚至把黑盒测试描述为基于无知的测试，因为测试员自始至终都不了解软件内部代码。我们认为这反映出对测试团队角色的根本误解。我们不反对测试员了解产品的工作原理。测试员对产品的了解得越多，了解产品的方式越多，越能够更好地测试它。但是，如果测试员主要关注的是源代码，以及能够从源代码导出的测试，则测试员所做的工作也许就是程序员已经做过的，并且测试员关于这些代码的知识要少于程序员。制造问题的思路，无法解决问题。
测试员不只是游客 测试员对产品做的大量不是测试的事，有助于测试员对产品的了解。测试员可以浏览产品，看看产品由什么组成，怎么工作。这样做有很高的价值，但这不能算是测试。测试员和游客之间的差别在于，测试员把精力放在评估产品上，而不只是见证产品。虽然不必事先预测产品应该表现出的行为，但是试验产品能力的活动还没有成为测试，除非而且直到测试员运用某种如果问题存在就能标识的原理或过程时，这种活动才能成为测试。
探索要求大量思索 探索就是侦查，是没有边界的搜索。可把探索看作是在太空中遨游，需要前向、后向和侧向思索。
前向思索。根据已知探索未知，从看到的探索还没有看到的，注意支流和副作用。例如，看到一个打印菜单项，点击看看会发生什么。 后向思索。从怀疑或想象的东西返回到已知，尝试证实或否定自己的推测。例如：怀疑是否有打印这个文档的方法，于是打开菜单并检查是否有打印菜单项。 侧向思索。让自己的工作由于新冒出的想法而转移，然后再将探索主题返回到主线索上。例如：这个图很有意思。嘿！我想该打印一些更复杂的图，看看会怎么样。 即使没有要测试的产品，也可以探索。可以使用同样的思索过程探索一组文档，或与程序员面谈。通过构建更丰富、更具想象力的产品模型，探索也会不断取得进展。这些模型以后会使测试员设计出有效的测试。
运用试探法快速产生测试思路 试探法是一种经验规则，是一种基于经验做出猜测的方法。由于可能的测试用例数量是无限的，因此肯定要选出在所面临的时间和预算约束条件下有效的少量测试用例。有经验的测试员会收集并共享能够改进其猜测质量的测试试探方法。一组好的试探方法有助于很快地生成测试。以下是采用试探测试的一些例子：
测试边界。边界更有可能暴露规格说明的模糊问题。 测试所有错误信息。错误处理代码与主流功能代码相比，一般比较弱。 测试与程序员的配置不同的配置。程序员已经偏信自己的配置没有问题。 运行比较难设置的测试。在其他条件相同的情况下，易于设置的测试更有可能已经被执行过。 避免冗余测试。如果某个测试实际上是重复其他测试，就不会产生新价值。 为了明智地运用试验法，请注意：试探法中并没有智慧，智慧来自测试员。试探法所能够做的，只不过就是为测试员的思考提出建议。盲目使用自己并不了解的试探法并不是好的测试实践。在收集测试方法时，要了解每个方法背后的原理，以及更适用和不太适用的条件。</description></item><item><title>测试员的角色</title><link>https://goplscn.github.io/post/the-role-of-the-tester/</link><pubDate>Tue, 30 Jun 2020 10:40:43 +0000</pubDate><guid>https://goplscn.github.io/post/the-role-of-the-tester/</guid><description>一个角色就是一种关系。这意味着人们不能控制自己的角色，但可以协商。别人期望从测试员那里得到的可能并不合理。当测试员由于低质量的产品受到指责时（这种事时有发生），不管是谁指责，可能都存在分不清角色的问题。也许他们认为测试员的工作，就是在产品交付之前使用“质量魔术棒”敲打产品，他们也许认为测试员敲打得还不够狠。
当测试员清楚了自己的角色之后，在协商角色内容时，就有了在可能出现的任何情况下确立对自己预期的基础。但是，即使是清晰和恰当的测试角色也是一种苛求。
测试员的使命决定要做的一切 测试员的使命，可能要取决于自己的行业、公司、项目或团队的个性，测试项目也千差万别。把测试作为一种工艺发展的挑战，一直是建立测试实践对话所面临的困难，这种测试实践要跨越我们之间的文化和技术差异。这些差异中的很多内容，决定了测试团队的不同使命。以下任何要求都可能决定测试员的使命。
快速找出重要软件问题。 对产品质量提出总体评估。 确认产品达到某种具体标准。 帮助客户改进产品质量和可测试性。 保证测试过程能够达到可分清责任的标准。 就测试和测试员协作方式培训客户。 采用特定的方法集或遵循特定的规则集。 帮助预测和控制成本。 帮助客户改进其过程。 以最小化成本、时间或尽可能减少副作用的方式，完成自己的工作。 为满足特定客户要求，完成所有必要的工作。 如果测试员将时间和精力都投入到客户并不关心的需求上，就会冒做无关工作或生产率低的风险。测试员要与自己的经理协商使命问题，并明确使命，如果不能就使命达成一致意见，就不会有做任何工作的好基础。
**如果测试员不知道该做什么怎么办？**一种回答是评审使命。这样做可以找出自己的核心问题。如果测试员明确自己的测试使命，就可以为自己的工作辩护，并明确地确定下一步要做什么。测试员还可以用简单的描述，向其他人解释自己的角色。如果由于某种原因不能完成自己的使命，应该立即把这个问题汇报给管理层。
**如果测试员确切地知道要做什么该怎么办？**经常重新考虑自己的使命，保证自己的计划不会由于过于偏重测试问题的一个方面，而忽略其他方面。
测试员为很多客户服务 测试是一种服务角色，要乐于接受这种角色，因为测试员提供的服务是至关重要的。服务就意味着有客户，即要被服务的人。测试员是否成功，主要是看其是否很好地满足了客户的要求和最佳利益。这不会太难，不过测试会有很多客户，这些客户都有自己的需要，而且他们的各种需要不一定一致。
项目经理。项目经理有资格了解测试员的工作进展并施加影响。测试员根据要求向其报告工作状态。指挥项目是项目经理的特权。测试员的责任就是告诉项目经理自己能做什么，不能做什么，有关项目的决策和条件会对测试产生什么影响。 程序员。通过尽可能迅速地提供好的错误报告，使得程序员的工作更容易一些。努力提高自己的技能并了解产品，以免用错误的或用毫无意义的报告浪费程序员的时间。如果测试员可以做到这一点，就可以赢得更多的信任，而这种信任又可以转化为支持和影响。 技术文档编写员。与测试员一样，负责编写文档和在线帮助的技术文档编写员也不能得到产品的完整信息。测试员可以帮助他们理解产品到底怎样发挥效能，并为其指出文档中的错误。技术文档编写员也会帮助测试员。当技术文档编写员研究产品，以及必须阅读文档的用户会怎样使用产品时，会了解到一些测试员不知道的信息。如果测试员与技术文档编写员有很好的关系，编写员就会告诉测试员有关产品的新特性、新用法、测试计划中的漏洞和他们所发现的软件问题。这些问题中的一部分永远也不会被报告，除非某个文档编写员知道哪个测试员关心这些程序问题。 技术支持员。遗留在产品中的任何问题都会为技术支持员带来负担。测试员通过告诉技术支持员可能会给用户带来麻烦的产品问题，向其提供服务。如果测试员在开发期间与技术支持员一起工作，有时技术支持员会帮助测试员找出应该更正的软件问题。测试员也应该通过研究发现的难题，为技术支持员提供帮助。通过这种方式，能够把测试员与技术支持员拉得更近，进而与客户也更近了。 市场开发员。市场开发员需要了解产品中任何与产品应该提供给客户的关键利益不一致的地方。对于程序员来说是很小的程序问题，对于市场开发员来说可能会是至关重要的问题。他们也许能意识到这种程序问题会使客户较难完成某种重要任务。此外，通过评审市场开发计划文档或描述，测试员可以帮助市场开发员对产品能力有更精确的认识。 管理层和项目相关人员。测试员服务于公司业务，这也是为什么测试员必须小心，不要像个质量狂，而不是通情达理的人的原因。特别是到了项目要结束的时候，测试员要以兼顾公司短期和长期利益的方式完成自己的职责。要以明确、简洁的词汇编写测试状态报告，一遍执行经理能够感到有做出决策的依据。 用户。在测试员的心中，要想着将要使用该产品的人。当然，用户的满意是项目的最高利益。但是还要考虑满足主要用户对项目团队的特殊要求。 以上列出的各条没有什么特别顺序，不过在实际项目中可能有一定顺序，因此要认真研究，找出对项目最重要的人，找出要服务的人。这是做好测试工作的第一步。
当心“完备的”测试 测试员的任务就是找出并报告重要的程序问题，但是不会发现所有的程序问题。为了发现全部程序错误，测试员必须检查所有可能有问题的地方，要在所有可能发生的不同条件下观察这些地方，还需要一种十分可靠的方法，当所有类型的程序错误发生时，都能够识别出来。如果测试员认为自己能够做到这些，那么要么产品非常简单，要么测试员的想象力太差。
知道并承认自己不能做所有的事之后，测试员必须选择如何使用自己的时间。
有一些测试员承认自己不知道是否发现了产品中的全部问题，但仍然不准确地讨论结束测试的含义。”对这个产品我需要测试5天“可以解释为，他可以在5天之内对产品进行完备的测试，也可能意味着他会在5天内发现所有问题。完备性常常是隐含地表示出来的，而不是明说出来的。不管是哪种情况，这都是必须小心对待的概念。请考虑完备测试可能的含义：
完全发现了产品中的每个问题。 完全检查了产品的每个部分。 完成了自认为是有用和经济的测试。 尽自己所能，完全达到了项目团队制定的目标。 完成了约定的测试。 完成了在一定条件下人所能够测试的所有内容。 完成了自己所承担的测试部分，不考虑其他人的工作。 完成了对产品很广、但是不深的测试。 完成了对产品的一种测试。 用完了分配给测试的时间。 如果测试员小心地澄清自己的意思，不要有“完备”、“完成”、“结束”等含义，则可能会安全，由于有些工作没有做而受到的责备可能更少，在收到责备时可以更好地为自己辩护。请注意，”完备“的定义并不是在项目一开始就能够最终确定的，随着测试项目的进展，随着新测试任务的突然出现，需要重新考虑。
为了解决在完备性上的普遍沟通问题，可让客户想想了解测试过程。总结自己实施的测试，以及为什么值得实施这些测试，并告诉客户自己没有做的其他值得做的测试，以及为什么没有做这些测试。
迅速找出重要程序问题 测试员的使命很可能包括找出重要的（与无意义相反）程序问题，而且要迅速找出。如果是这样，那么这对测试员所执行的测试意味着什么呢？
首先测试经过变更的部分，然后测试没有变化的部分。修改和更新都意味着新的风险。 首先测试核心功能，然后测试辅助功能，测试产品所完成的关键和常用功能，测试完成产品基本任务的功能。 首先测试能力，然后测试可靠性。先测试每个功能是否完全能用，然后再深入检查任何一个功能在很多不同条件下表现如何。 首先测试常见情况，然后测试少见情况。使用常用的数据和使用场景。 首先测试场景威胁，然后测试罕见威胁。用最有可能出现的压力和错误情况进行测试。 首先测试影响大的问题，然后测试影响小的问题。测试在出现失效的情况下会产生大量破坏的产品部件。 首先测试最需要的部分，然后测试没有要求的部分。测试对团队其他人有重要意义的任何不等的任何问题。 测试员如果对产品、产品必须与之交互的软件和硬件以及将使用的人越了解，越有可能更快地找出重要问题。应好好研究这些方面的内容。
跟着程序员走 为程序员提供支持，很可能是测试员使命的关键部分。在测试员测试程序员正在编写或刚刚完成的程序时，测试员的反馈有助于提高程序员的工作效率。程序员交付软件后，应该马上测试；程序员修改代码后，应该马上测试所做的变更。尽可能建立最短、最快的反馈环路。当程序员正在苦苦地思索测试员刚刚发现的程序问题时，测试员又开始寻找更多的程序问题。（对于测试员来说，）理想情况是，程序员为了修改测试员找出的程序问题忙得团团转，使程序员，而不是测试员，成为项目的瓶颈。
别指望任何人会理解测试，或理解测试员需要什么条件才能搞好测试 让客户了解为了有效地完成测试工作都需要什么条件，完全要靠测试员自己。测试员要受管理层和程序员决策的很大影响。如果他们的计划不明确，或设计出的产品很难测试，测试工作就会很难进行。测试员也许不会得到想要的一切，但是测试员可以向管理层和程序员提供帮助自己的机会。
管理层和程序员并不是不关心测试或质量，他们也许只是不理解自己的行动会对测试过程产生的影响。测试工作的一个重要部分就是向客户解释测试。测试员的解释就像是流感疫苗，有利于健康而又不那么痛苦，但是疫苗的作用会逐渐衰退，必须一遍又一遍地解释。
摘抄自《软件测试经验与教训》</description></item><item><title>如何编写好的测试用例</title><link>https://goplscn.github.io/post/how-to-write-good-test-cases/</link><pubDate>Tue, 23 Jun 2020 22:51:59 +0000</pubDate><guid>https://goplscn.github.io/post/how-to-write-good-test-cases/</guid><description>什么是测试用例 测试用例（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。是将软件测试的行为活动做一个科学化的组织归纳，目的是能够将软件测试的行为转化成可管理的模式。同时测试用例也是将测试具体量化的方法之一，不同类别的软件，测试用例是不同的。
通俗的讲：就是把整个测试流程的操作步骤用按照一定的格式用文字描述出来。
为什么要写测试用例 *测试*用例是测试执行的指导；是测试执行的实体，是测试方法、测试质量、测试覆盖率的重要依据和表现形式；是团队内部交流以及交叉测试的依据，便于测试工作的跟踪管理，包括测试执行的进度跟踪，测试质量的跟踪，以及测试人员的工作量的跟踪和考核；在测试执行工作开展前完成测试用例的编写，可以避免测试工作开展的盲目性；测试用例是说服用户相信产品质量的最佳依据，同时也可以提供给客户作为项目验收的依据。
1、 理清思路，避免遗漏测试点
理清思路是我们认为最重要的一点，有的系统本来就是一个大而复杂的项目，我们需要把项目功能细分，根据每一个功能通过编写用例的方式来整理我们测试系统的思路，避免遗漏掉要测试的功能点。
2、 跟踪测试进度进展
通过编写测试用例，执行测试用例，我们可以很清楚的知道我们的测试进度，方便跟踪我们的测试进度。
3、 回归测试
首先我们的系统不是测一遍就完了的，我们需要在开发环境上测试，测试环境上还要进行回归，其次还有可能涉及到合并测试，而且也有可能会有不同的人在不同的阶段进行测试，那么我们就需要测试用例来规范和指导我们的测试行为。
4、 历史参考
在我们所做项目的各个版本中，也许会有很多功能是相同或相近的，我们对这类功能设计了测试用例，便于以后我们遇到类似功能的时候可以做参考依据。
另外如果产品发布后出现了发布缺陷，测试用例也是分析发布后缺陷的依据之一。
一、编写用例的重要性
1.深入了解需求的过程，一个项目立项开始，测试就开始介入，我们从产品的PRD文档、用户交互图，视觉图等相关文档去熟悉产品的各个模块，各个业务流程。或者在产品规划和设计阶段，测试开始熟悉产品。而编写用例的过程中，会充分的思考产品需求的细枝末节，需求的不合理、有矛盾、不明确的地方，还能对产品提出更好的建议，监督产品对需求做出更加详细的设计。整个过程是对需求深入了解的过程，产品的整个印象都在测试脑海里。
**2.测试执行的指导，**用例编写是把产品需求转换为一种可操作步骤的行为，方便以后作为测试的标准，有步骤有计划的进行测试。如果没有这个标准，会使你的测试过程无计划，无目标，变成一个放任主流的状态，完全没有受控性。这样的产品质量保证显然是空谈。
**3.规划测试数据的准备，**在我们的实践中测试数据是与测试用例分离的。按照测试用例配套准备一组或若干组测试原始数据，以及标准测试结果。尤其象测试报表之类数据集的正确性，按照测试用例规划准备测试数据是十分必须的。除正常数据之外，还必须根据测试用例设计大量边缘数据和错误数据
**4.反应测试进度，**测试人员开始按照测试用例的描述测试，每过完一个用例标记完成；这样测试也知道自己做过哪些操作，避免没有目的随机测试。并且通过测试用例的执行条数，大致了解该模块的测试进度。
**5.举一反三发现潜藏缺陷，**测试人员在执行用例的过程中往往会突然发现当初设计的用例步骤中，还可以做这样一个操作，于是发现了bug，这又体现了测试用例的作用， 帮助发现拓展测试范围，扩大测试覆盖面，发现软件中潜藏的缺陷。
6.分析缺陷的标准 通过收集缺陷，对比测试用例和缺陷数据库，分析确证是漏测还是缺陷复现。漏测反映了测试用例的不完善，应立即补充相应测试用例，最终达到逐步完善软件质量。而已有相应测试用例，则反映实施测试或变更处理存在问题。
好用例的标准 https://zhuanlan.zhihu.com/p/94993557 https://zhuanlan.zhihu.com/p/24308453 https://blog.csdn.net/qq_28967695/article/details/73609070 https://yq.aliyun.com/articles/130204 https://zhuanlan.zhihu.com/p/74623927 https://blog.csdn.net/deyili/article/details/6640259 https://zhuanlan.zhihu.com/p/89633142 https://www.jianshu.com/p/d8931aa92b10 好用例的标准
是否可以发现Bug 设计测试用例的目的就是为了发现bug，如果bug都发现不了，怎么能称得上是一个好的测试用例呢？
是否够高效 一个好的测试用例应该不止测试一个测试点，从而减少需要的用例总量。但也不能包含太多不想关的测试点，否则你这个用例就没法测试了，并且给开发的debug造成困难。
是否够经济 这个测试用例执行起来是否容易，分析和debug是否要花太多代价，都是值得考虑的，毕竟咱也要站在组织的角度来看待测试这个事，公司是为了盈利而做这些事，而不是为了做测试而测试。
是否有足够的扩展性 主要是考察测试用例在维护时是否要花费很大的代价。
1、用例覆盖程度
　毫无疑问，这一点应该是最重要的，无需多说，覆盖率最大化是一套测试用例的最重要评价标准，如果漏测就杯具了。
2、用例是否已经达到工作量最小化
　在满足用例覆盖程度最大化的前提下，应该尽量减小执行用例所需要的工作量。这些方面的方法有不少，如条件覆盖，分支覆盖，正交覆盖等方法。面对不同的测试对象，也有不同的方法来保证：对于网页背后的php逻辑，可以通过在网页上测试后，用一些工具比如xdebug来统计代码覆盖率；对于向外提供接口的server，采用的方式就是分析在外面暴露的接口设计用例，大致的通过接口参数来估计一下分支判断的情况。
3、用例的分类以及描述是否足够清晰
　用例的分类，在这里是指相同类型的用例是否放在一起了。例如：接口类的用例，参数的取值范围是1-3，但是现在却传入4；数据类用例，状态机现在位于状态2，却要求状态跳转到无法到达的4；逻辑类用例，正常功能的产出等。将相同类型的用例放在一起，有助于理清思路，清楚了解用例设计是否完备。
　用例的描述，是指描述的清晰程度是否能够形成文档。例如上面参数取值范围的例子，用例这样写：“传入错误的值”或者“传入非1-3的值”，明显没有写成“传入值4”有效。这与写程序一样，总是写闭区间的范围而不是开区间。
4、用例是否表明了测试目的
　写明用例的测试目的，对文档的易于理解性和工作交接的好处不言而喻，现代软件工程不可能只有一个人在做事情，项目于人员的变动也是难免的。在过程中留下足够的信息，可以在后续工作提高很多效率。
5、测试用例的易于维护性
　如果被测对象有所升级，测试用例的说明或者脚本是不是容易维护呢？例如在有状态机的情况下，测试用例之间是相互依赖的（即需要一定的执行顺序），这样被依赖的用例修改后，后端不需要同步根据修改。而如果用例之间没有相互依赖关系（如用例是自己造的数据，不是依赖于前端的产出），可能一旦有变化，就需要修改这两个。当然，这两种情况不能绝对的说哪种好，是需要看实际使用时候的情况进行取舍的。不过，通过一些系统性的工具支持，也会出现一种做法绝对性的好于另外一种的情况，情况很多，做法也有很多，在这里就不多说了。</description></item><item><title>HTML 特殊符号编码对照表</title><link>https://goplscn.github.io/post/html-chars/</link><pubDate>Thu, 14 May 2020 17:16:41 +0000</pubDate><guid>https://goplscn.github.io/post/html-chars/</guid><description>HTML 特殊符号编码对照表 特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 Α &amp;amp;Alpha; &amp;amp;#913; Β &amp;amp;Beta; &amp;amp;#914; Γ &amp;amp;Gamma; &amp;amp;#915; Δ &amp;amp;Delta; &amp;amp;#916; Ε &amp;amp;Epsilon; &amp;amp;#917; Ζ &amp;amp;Zeta; &amp;amp;#918; Η &amp;amp;Eta; &amp;amp;#919; Θ &amp;amp;Theta; &amp;amp;#920; Ι &amp;amp;Iota; &amp;amp;#921; Κ &amp;amp;Kappa; &amp;amp;#922; Λ &amp;amp;Lambda; &amp;amp;#923; Μ &amp;amp;Mu; &amp;amp;#924; Ν &amp;amp;Nu; &amp;amp;#925; Ξ &amp;amp;Xi; &amp;amp;#926; Ο &amp;amp;Omicron; &amp;amp;#927; Π &amp;amp;Pi; &amp;amp;#928; Ρ &amp;amp;Rho; &amp;amp;#929; Σ &amp;amp;Sigma; &amp;amp;#931; Τ &amp;amp;Tau; &amp;amp;#932; Υ &amp;amp;Upsilon; &amp;amp;#933; Φ &amp;amp;Phi; &amp;amp;#934; Χ &amp;amp;Chi; &amp;amp;#935; Ψ &amp;amp;Psi; &amp;amp;#936; Ω &amp;amp;Omega; &amp;amp;#937; α &amp;amp;alpha; &amp;amp;#945; β &amp;amp;beta; &amp;amp;#946; γ &amp;amp;gamma; &amp;amp;#947; δ &amp;amp;delta; &amp;amp;#948; ε &amp;amp;epsilon; &amp;amp;#949; ζ &amp;amp;zeta; &amp;amp;#950; η &amp;amp;eta; &amp;amp;#951; θ &amp;amp;theta; &amp;amp;#952; ι &amp;amp;iota; &amp;amp;#953; κ &amp;amp;kappa; &amp;amp;#954; λ &amp;amp;lambda; &amp;amp;#955; μ &amp;amp;mu; &amp;amp;#956; ν &amp;amp;nu; &amp;amp;#957; ξ &amp;amp;xi; &amp;amp;#958; ο &amp;amp;omicron; &amp;amp;#959; π &amp;amp;pi; &amp;amp;#960; ρ &amp;amp;rho; &amp;amp;#961; ς &amp;amp;sigmaf; &amp;amp;#962; σ &amp;amp;sigma; &amp;amp;#963; τ &amp;amp;tau; &amp;amp;#964; υ &amp;amp;upsilon; &amp;amp;#965; φ &amp;amp;phi; &amp;amp;#966; χ &amp;amp;chi; &amp;amp;#967; ψ &amp;amp;psi; &amp;amp;#968; ω &amp;amp;omega; &amp;amp;#969; ϑ &amp;amp;thetasym; &amp;amp;#977; ϒ &amp;amp;upsih; &amp;amp;#978; ϖ &amp;amp;piv; &amp;amp;#982; • &amp;amp;bull; &amp;amp;#8226; … &amp;amp;hellip; &amp;amp;#8230; ′ &amp;amp;prime; &amp;amp;#8242; ″ &amp;amp;Prime; &amp;amp;#8243; ‾ &amp;amp;oline; &amp;amp;#8254; ⁄ &amp;amp;frasl; &amp;amp;#8260; ℘ &amp;amp;weierp; &amp;amp;#8472; ℑ &amp;amp;image; &amp;amp;#8465; ℜ &amp;amp;real; &amp;amp;#8476; ™ &amp;amp;trade; &amp;amp;#8482; ℵ &amp;amp;alefsym; &amp;amp;#8501; ← &amp;amp;larr; &amp;amp;#8592; ↑ &amp;amp;uarr; &amp;amp;#8593; → &amp;amp;rarr; &amp;amp;#8594; ↓ &amp;amp;darr; &amp;amp;#8595; ↔ &amp;amp;harr; &amp;amp;#8596; ↵ &amp;amp;crarr; &amp;amp;#8629; ⇐ &amp;amp;lArr; &amp;amp;#8656; ⇑ &amp;amp;uArr; &amp;amp;#8657; ⇒ &amp;amp;rArr; &amp;amp;#8658; ⇓ &amp;amp;dArr; &amp;amp;#8659; ⇔ &amp;amp;hArr; &amp;amp;#8660; ∀ &amp;amp;forall; &amp;amp;#8704; ∂ &amp;amp;part; &amp;amp;#8706; ∃ &amp;amp;exist; &amp;amp;#8707; ∅ &amp;amp;empty; &amp;amp;#8709; ∇ &amp;amp;nabla; &amp;amp;#8711; ∈ &amp;amp;isin; &amp;amp;#8712; ∉ &amp;amp;notin; &amp;amp;#8713; ∋ &amp;amp;ni; &amp;amp;#8715; ∏ &amp;amp;prod; &amp;amp;#8719; ∑ &amp;amp;sum; &amp;amp;#8722; − &amp;amp;minus; &amp;amp;#8722; ∗ &amp;amp;lowast; &amp;amp;#8727; √ &amp;amp;radic; &amp;amp;#8730; ∝ &amp;amp;prop; &amp;amp;#8733; ∞ &amp;amp;infin; &amp;amp;#8734; ∠ &amp;amp;ang; &amp;amp;#8736; ∧ &amp;amp;and; &amp;amp;#8869; ∨ &amp;amp;or; &amp;amp;#8870; ∩ &amp;amp;cap; &amp;amp;#8745; ∪ &amp;amp;cup; &amp;amp;#8746; ∫ &amp;amp;int; &amp;amp;#8747; ∴ &amp;amp;there4; &amp;amp;#8756; ∼ &amp;amp;sim; &amp;amp;#8764; ≅ &amp;amp;cong; &amp;amp;#8773; ≈ &amp;amp;asymp; &amp;amp;#8773; ≠ &amp;amp;ne; &amp;amp;#8800; ≡ &amp;amp;equiv; &amp;amp;#8801; ≤ &amp;amp;le; &amp;amp;#8804; ≥ &amp;amp;ge; &amp;amp;#8805; ⊂ &amp;amp;sub; &amp;amp;#8834; ⊃ &amp;amp;sup; &amp;amp;#8835; ⊄ &amp;amp;nsub; &amp;amp;#8836; ⊆ &amp;amp;sube; &amp;amp;#8838; ⊇ &amp;amp;supe; &amp;amp;#8839; ⊕ &amp;amp;oplus; &amp;amp;#8853; ⊗ &amp;amp;otimes; &amp;amp;#8855; ⊥ &amp;amp;perp; &amp;amp;#8869; ⋅ &amp;amp;sdot; &amp;amp;#8901; ⌈ &amp;amp;lceil; &amp;amp;#8968; ⌉ &amp;amp;rceil; &amp;amp;#8969; ⌊ &amp;amp;lfloor; &amp;amp;#8970; ⌋ &amp;amp;rfloor; &amp;amp;#8971; ◊ &amp;amp;loz; &amp;amp;#9674; ♠ &amp;amp;spades; &amp;amp;#9824; ♣ &amp;amp;clubs; &amp;amp;#9827; ♥ &amp;amp;hearts; &amp;amp;#9829; ♦ &amp;amp;diams; &amp;amp;#9830; &amp;amp;nbsp; &amp;amp;#160; ¡ &amp;amp;iexcl; &amp;amp;#161; ¢ &amp;amp;cent; &amp;amp;#162; £ &amp;amp;pound; &amp;amp;#163; ¤ &amp;amp;curren; &amp;amp;#164; ¥ &amp;amp;yen; &amp;amp;#165; ¦ &amp;amp;brvbar; &amp;amp;#166; § &amp;amp;sect; &amp;amp;#167; ¨ &amp;amp;uml; &amp;amp;#168; © &amp;amp;copy; &amp;amp;#169; ª &amp;amp;ordf; &amp;amp;#170; « &amp;amp;laquo; &amp;amp;#171; ¬ &amp;amp;not; &amp;amp;#172; ­ &amp;amp;shy; &amp;amp;#173; ® &amp;amp;reg; &amp;amp;#174; ¯ &amp;amp;macr; &amp;amp;#175; ° &amp;amp;deg; &amp;amp;#176; ± &amp;amp;plusmn; &amp;amp;#177; ² &amp;amp;sup2; &amp;amp;#178; ³ &amp;amp;sup3; &amp;amp;#179; ´ &amp;amp;acute; &amp;amp;#180; µ &amp;amp;micro; &amp;amp;#181; &amp;quot; &amp;amp;quot; &amp;amp;#34; &amp;lt; &amp;amp;lt; &amp;amp;#60; &amp;gt; &amp;amp;gt; &amp;amp;#62; ' &amp;amp;#39;</description></item><item><title>Homebrew 使用国内源</title><link>https://goplscn.github.io/post/homebrew-speed-up-in-china/</link><pubDate>Fri, 10 Jan 2020 10:08:33 +0000</pubDate><guid>https://goplscn.github.io/post/homebrew-speed-up-in-china/</guid><description>homebrew 更改国内源 修改为国内源加速 1cd &amp;#34;$(brew --repo)&amp;#34; 2git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 3cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 4git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 5brew update 6cd &amp;#34;$(brew --repo)&amp;#34;/Library/Taps/caskroom/homebrew-cask 7git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 8echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.zshrc 9source ~/.zshrc 10brew update 11brew doctor 或者使用阿里云镜像 使用bash 1# 替换brew.git: 2cd &amp;#34;$(brew --repo)&amp;#34; 3git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 4# 替换homebrew-core.git: 5cd &amp;#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;#34; 6git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 7# 应用生效 8brew update 9# 替换homebrew-bottles: 10echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.</description></item><item><title>pyenv in pratical</title><link>https://goplscn.github.io/post/pyenv-in-pratical/</link><pubDate>Wed, 08 Jan 2020 10:15:12 +0000</pubDate><guid>https://goplscn.github.io/post/pyenv-in-pratical/</guid><description>pyenv 工程实践指南 安装 brew install pyenv
或者
Python 3.7 依赖 OpenSSL 1.0.2e 或更高版本，手动安装OpenSSL或者直接安装3.6最新版本
1git clone https://github.com/pyenv/pyenv.git ~/.pyenv 2echo &amp;#39;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile 3echo &amp;#39;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile 4echo -e &amp;#39;if command -v pyenv 1&amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then\n eval &amp;#34;$(pyenv init -)&amp;#34;\nfi&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile 5 6git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv 7echo &amp;#39;eval &amp;#34;$(pyenv virtualenv-init -)&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile 8 9sudo yum install openssl-devel zlib-devel python-devel -y 10 11pyenv install -v 3.6.10 12# 若下载失败则手动下载上传到cache目录再安装 13mkdir ~/.</description></item><item><title>结构化思维方法</title><link>https://goplscn.github.io/post/structure-thinking-methods/</link><pubDate>Sun, 05 Jan 2020 15:07:09 +0000</pubDate><guid>https://goplscn.github.io/post/structure-thinking-methods/</guid><description>思维混乱，是因为大脑没有结构 请你花10秒钟的时间，记住以下的20个数字：
{% asset_img afb4f724da3e26b51ff951d80144cd7e.jpeg From: P3.PSTATP.COM %}
{% asset_img 9d27a59d115a827c28f28479f6459ebf.jpeg From: P1.PSTATP.COM %}
好，我们再来试一组数字，还是花10秒钟来记住它：
{% asset_img e6d0cefc2d6d0214f0c562fc8d9300ac.jpeg From: P1.PSTATP.COM %}
{% asset_img cb16fdd47a9dc18936a7bfaa820a1dee.jpeg From: P3.PSTATP.COM %}
其实这2组的20个数字是一样的，但是不是觉得第二组一下子就记住了？
为什么会这样？ 因为第二组数据更符合我们大脑的使用习惯，数字与数字之间有清晰的逻辑和结构。
我们大脑处理信息有2个规律：
太多的信息记不住 喜欢有规律的信息 可你有没有遇到过这样的情况：有人口若悬河的和你讲了半天，他说的每个字你都听得懂，然而组合在一起，你并不知道他想说什么，内容没有逻辑，语句没有重点，就像刚才那一串杂乱的数字...
听他说话时间一长，你甚至开始头疼，变得焦躁，心里骂到：“你TM到底想说什么...？”
你别觉得听着难受，讲的人，他自己也许更难受！
明明心里有很多想法，甚至做了上百页的PPT，但就是讲不清楚….为什么会这样？
因为思维没有结构 我们思考问题的时候，脑子里的想法会不断地涌现出来，看似有很多，却杂乱无章，就像是衣橱里的一堆没有整理的衣服，彼此缠绕，互相堆砌在一起。
{% asset_img 56bad163e44cd84dfcf2c96659152d4c.jpeg From: P1.PSTATP.COM %}
当有人问你，你能说说你有哪些衣服吗？
“嗯....我有很多衣服（想法）...”
能详细点说吗？ “我有一条蓝裤子，一条橘黄色裙子，一件白衬衫，还有件灰白条纹衬衫，一条牛仔裤，一条蓝色竖条纹的裤子，还有顶黑色的帽子，哦对了，还有一条蓝色裤子（这个刚才好像说过了)…”
￥#%@#￥%@… 你到底有些啥？
“我刚才说的都是我有的啊…”
语言是思维的传声筒
如果你的思维没有经过整理，就会像这堆乱糟糟的衣服，你拥有他们，却无法理解他们！
自己看着难受，别人听着难懂！
那怎么办？如何让思维变得既全面又有序呢？
你需要结构化思维 所谓结构化思维，就像是把衣橱里的这些衣服，分门别类的整理好。
比如按季节分类，按穿着场合分类，按服装风格分类等等..
{% asset_img 9ea3f85e5bfe2881e4d719f257ce3bc4.jpeg From: P1.PSTATP.COM %}
这时候，别人再问你：你有些什么衣服呢？
你回答：我一共有208件装备，分为：
夏季、春秋季、冬季三大类； 每个季节的衣服又分为工作装、休闲装、宴会装、运动装四大系列； 其中，休闲装里有田园、淑女、简约三种风格； 每种风格的衣服，拥有深色、浅色各3套搭配； 另外配了4双运动鞋，5双皮鞋，6双休闲鞋，7个包包，8顶帽子来应对不同需要.</description></item><item><title>结构化思维</title><link>https://goplscn.github.io/post/structure-thinking/</link><pubDate>Sat, 04 Jan 2020 20:50:13 +0000</pubDate><guid>https://goplscn.github.io/post/structure-thinking/</guid><description>技术人具备“结构化思维”意味着什么? 作者:张建飞 高级技术专家
在日常工作中，我们时常会碰到这样的情况，有的人讲事情逻辑非常混乱，罗列了很多事项，却把握不到重点，无法把一件事情说清楚。这种思维混乱是典型的缺少结构化思维的表现。结构化思维非常重要，不仅仅体现在表达上，也体现在在我们分析问题的过程中。具备结构化思维，才能将问题分析地更全面、更深刻。
什么是结构化思维? 那么到底是什么是结构化思维呢?简单来说，结构化思维的定义就是:逻辑 + 套路。
表达要有逻辑 所谓逻辑是指我们的结构之间必须是有逻辑关系的。例如，你说话的时候用“第一、第二、第三”这个逻辑顺序是合理的，但是，用“第一，第二，第四”就会显得很奇怪。当然，即使你用了”一、二、三”，也不一定就意味着你的内容有逻辑关系。
想让内容有逻辑关系，我们要学会四种组织思想的逻辑关系:
1)演绎(因果)顺序:“大前提、小前提、结论”的演绎推理方式就是演绎顺序。
比如，经典三段论:所有人都要死，苏格拉底是人，苏格拉底要死。
2)时间(步骤)顺序:“第一、第二、第三”，“首先、然后、再者”等，很多的时间顺序同时也是因果顺序。
3)空间(结构)顺序:“前端、后端、数据”，“波士顿、纽约、华盛顿”，化整为零(将整体分解为部分)等都是空间顺序。
4)程度(重要性)顺序:比如“最重要、次重要、不重要”等。 实际上，所有的逻辑关系都在这四种顺序之内。只要我们的思想和表达在这四种逻辑顺序之内，就是有逻辑的，否则就会显得没有逻辑性。
做事要有套路 套路是指我们解决问题的方法论，这个也非常重要。比如，5W2H 分析法就是一个非常好的，可以帮助我们分析问题的一个”套路”。试想一下，面对任何一个问题，你都能从 Why、Who、When、Where、What、How 和 How much(如下图所示)，七个方面去思考。是不是比不知道这个方法论的人，用点状的思考，5W2H 分析法就全面得多。
{% asset_img image-20200104213012385.png %}
图片来源:https://www.toutiao.com/i6619057728725729800/
例如，我们在对问题域进行分析和领域知识提炼的时候，就可以用上 5W2H。 5W2H 模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。
{% asset_img image-20200104213123105.png %}
逻辑是一种能力，而套路是方法论，是经验。逻辑是道的东西，而方法论是术的东西。二者都很重要，只有熟练的掌握二者我们才能更好的进行结构化思考。
如何进行结构化思考? 逻辑性和方法论是结构化思维的底层，那么如何进行结构化思考呢?这也是有方法论的，总的来说是有两个步骤，首先是“建立中心”，然后再进行“分解”。
建立中心 建立中心也就是要定义清楚要解决的问题，要明确目标。是我们结构的顶层节点，也是一种以终为始的思考方式。也就是说，我们首先要搞清楚 why，然后再进行 how。
★ 建立中心有两种方式:
自上而下:适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。
自下而上:对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。 建立中心通常不会是一次成型的，随着对问题理解的变化，对中心的抽象也会进行相应的调整。不同的抽象层次其面对的问题宽度是不一样的。具体要用哪个层次的抽象作为“中心”，要视具体情况而定。
比如面对“系统 bug 多”的问题，向上抽象是“提升代码质量”，向下抽象是 “加强测试”，都可以作为中心，选择哪个为中心取决于你当前要解决的问题是什么。
{% asset_img image-20200104213328809.png %}
结构化分解 确定完中心之后，我们需要构建一个结构，使用结构化的思维对问题进行分解。 分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序。
在做空间分解的时候，要注意满足 MECE(Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽)原则。</description></item><item><title>用例设计方法简介</title><link>https://goplscn.github.io/post/test-case-design-intro/</link><pubDate>Wed, 25 Dec 2019 16:04:52 +0000</pubDate><guid>https://goplscn.github.io/post/test-case-design-intro/</guid><description>黑盒测试用例设计方法 黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推导法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景图法等。
（一）等价类划分法 定义：等价类划分法是把所有可能输入的数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类方法是一种重要的、常用的黑盒测试用例设计方法。
等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试，因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。等价类划分有两种不同的情况：有效等价类和无效等价类。
有效等价类，是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明所规定的功能和性能。
无效等价类，指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能多个。
划分标准： 完备测试、避免冗余 划分等价类重要的是：集合的划分、划分为互不相交的一组子集，而子集的并是整个集合 并是整个集合：备性 子集互不相交：保证一种形式的无冗余性 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到“相同的执行路径”。 划分方法： 在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0~100
在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类：
在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。
在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。
例：输入条件说明学历可为：专科、本科、硕士、博士四种之一，则分别取这四种的四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。
在规定了输入数据必须遵守的规则情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；
在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应在将该等价类进一步的划分为更小的等价类。
转化为测试用例： 在确立了等价类后，可建立等价类表，列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：
为每一个等价类规定一个唯一的编号； 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止； 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。 实例1：三角形问题 某程序规定：“输入三个整数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形、等边三角形时，分别做计算。。。”用等价类划分方法为该程序进行测试用例设计。
分析题目中给出和隐含的对输入条件的要求：
（1）整数 （2）三个数（3）非零数（4）正数
（5）两边之和大于第三边（6）等腰 （7）等边
如果a、b、c满足条件（1）~（4），则输出下列四种情况之一：
如果不满足条件（5），则程序输出为“非三角形” 如果三条边相等即满足条件（7），则程序输出为“等边三角形” 如果只有两条边相等，及满足条件（6），则程序输出为“等腰三角形” 如果三条边都不相等，则程序输出为“一般三角形” 列出等价类表并编号 {% asset_img a11ae05ff369cf3b43bce5841d97e849.png UML.ORG.CN %}
覆盖有效等价类的测试用例：</description></item><item><title>Android随机测试工具Monkey简介</title><link>https://goplscn.github.io/post/android-adb-shell-monkey-abc/</link><pubDate>Mon, 23 Dec 2019 16:11:14 +0000</pubDate><guid>https://goplscn.github.io/post/android-adb-shell-monkey-abc/</guid><description>Monkey 是一个在模拟器或设备上运行的程序，可生成伪随机用户事件（例如点击、轻触或手势）流以及很多系统级事件。您可以使用 Monkey 以随机且可重复的方式对正在开发的应用进行压力测试。
概览 Monkey 是一个命令行工具，可以在任何模拟器实例或设备上运行。它会将伪随机用户事件流发送到系统中，从而在您正在开发的应用软件上进行压力测试。
Monkey 包含许多选项，主要分为以下四个类别：
基本配置选项，例如设置要尝试的事件数。 操作限制条件，例如将测试对象限制为单个软件包。 事件类型和频率。 调试选项。 Monkey 在运行时会生成事件并将其发送到系统。它还会监视被测系统并查找三种特殊情况：
如果您已将 Monkey 限制为在一个或多个特定软件包中运行，它会监视转到任何其他软件包的尝试并阻止它们。 如果应用崩溃或收到任何未处理的异常，Monkey 会停止并报告错误。 如果应用生成“应用无响应”错误，Monkey 会停止并报告错误。 根据您选择的详细程度级别，您还将看到有关 Monkey 进度和所生成事件的报告。
Monkey 的基本用法 您可以使用开发计算机上的命令行启动 Monkey，也可以通过脚本启动。由于 Monkey 在模拟器/设备环境中运行，因此您必须从该环境中通过 shell 启动它。为此，您可以在每个命令前面加上 adb shell，或者直接进入 shell 并输入 Monkey 命令。
基本语法如下：
1$ adb shell monkey [options] &amp;lt;event-count&amp;gt; 如果未指定任何选项，Monkey 将以静默（非详细）模式启动，并将事件发送到目标上安装的任何（及所有）软件包。下面是一个更典型的命令行，它会启动您的应用并向其发送 500 个伪随机事件：
1$ adb shell monkey -p your.package.name -v 500 命令选项参考 下表列出了您可以在 Monkey 命令行中添加的所有选项。
类别 选项 说明 常规 --help 输出简单的使用指南。 -v 命令行上的每个 -v 都会增加详细程度级别。级别 0（默认值）只提供启动通知、测试完成和最终结果。级别 1 提供有关测试在运行时（例如发送到您的 Activity 的各个事件）的更多详细信息。级别 2 提供更详细的设置信息，例如已选择或未选择用于测试的 Activity。 事件 -s 伪随机数生成器的种子值。如果您使用相同的种子值重新运行 Monkey，它将会生成相同的事件序列。 --throttle 在事件之间插入固定的延迟时间。您可以使用此选项减慢 Monkey 速度。如果未指定，则没有延迟，系统会尽快地生成事件。 --pct-touch 调整轻触事件所占百分比。（轻触事件是指屏幕上的单个位置上的按下/释放事件。） --pct-motion 调整动作事件所占百分比。（动作事件包括屏幕上某个位置的按下事件，一系列伪随机动作和一个释放事件。） --pct-trackball 调整轨迹球事件所占百分比。（轨迹球事件包括一个或多个随机动作，有时后跟点击。） --pct-nav 调整“基本”导航事件所占百分比。（导航事件包括向上/向下/向左/向右，作为方向输入设备的输入。） --pct-majornav 调整“主要”导航事件所占百分比。（这些导航事件通常会导致界面中的操作，例如 5 方向键的中间按钮、返回键或菜单键。） --pct-syskeys 调整“系统”按键事件所占百分比。（这些按键通常预留供系统使用，例如“主屏幕”、“返回”、“发起通话”、“结束通话”或“音量控件”。） --pct-appswitch 调整 Activity 启动次数所占百分比。Monkey 会以随机间隔发起 startActivity() 调用，以最大限度地覆盖软件包中的所有 Activity。 --pct-anyevent 调整其他类型事件所占百分比。这包括所有其他类型的事件，例如按键、设备上的其他不太常用的按钮等等。 约束 -p 如果您通过这种方式指定一个或多个软件包，Monkey 将仅允许系统访问这些软件包内的 Activity。如果应用需要访问其他软件包中的 Activity（例如选择联系人），您还需要指定这些软件包。如果您未指定任何软件包，Monkey 将允许系统启动所有软件包中的 Activity。要指定多个软件包，请多次使用 -p 选项 - 每个软件包对应一个 -p 选项。 -c 如果您通过这种方式指定一个或多个类别，Monkey 将仅允许系统访问其中一个指定类别中所列的 Activity。如果您没有指定任何类别，Monkey 会选择 Intent.</description></item><item><title>自动化测试入门级用例编写建议</title><link>https://goplscn.github.io/post/autotest-abc-and-case-suggest/</link><pubDate>Wed, 18 Dec 2019 14:51:34 +0000</pubDate><guid>https://goplscn.github.io/post/autotest-abc-and-case-suggest/</guid><description>自动化测试 一般是指软件测试的自动化，软件测试就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。
进阶图谱 新手入门 任职要求 有良好的沟通和协调能力，理解能力、逻辑分析能力，有责任心和团队合作精神； 熟练掌握javascript工具； 掌握一种以上自动化测试工具； 熟悉掌握计算机语言，如：C/C++/C#，Java，JS等。 任职标准 参与日常项目测试，编写测试用例，执行测试，确保项目质量和进度； 追踪项目Bug修改情况，注意寻求解决问题方法； 编写自动化测试脚本，主动寻求任何提高测试效率的方法； 主动提供反馈和优化建议，持续改进项目质量； 参与项目性能测试和安全测试； 熟悉web端和移动端的自动化测试流程、方法； 熟练使用常用的自动化测试工具,具备独立完成并维护测试脚本的编写能力。 初级选手 任职要求 熟悉Java，Eclipse, IDEA等开发环境； 了解一种以上自动化测试框架如Selenium/Appium/Uiautomator/Uiautomation/Robotium。 任职标准 根据测试用例创建并提交测试脚本； 关注测试结果并及时更新测试脚本； 维护并更新测试框架及工具； 维护CI和测试环境。 高级专家 任职要求 移动客户端产品测试工作经验（Android，iOS）； 熟悉常用各种测试工具，如：用例管理工具，bug管理工具，性能工具； 熟悉SQL语言以及MySQL数据库操作； 掌握Java编程； 有基于Selenium的自动化测试框架开发经验； 有性能测试经验，掌握Loadrunner工具； 有接口自动化脚本开发经验； 熟练使用linux，能独立完成各类搭建部署工作； 熟悉Oracle或MySQL等数据库； 善于发现、分析和总结问题，富有团队精神，责任心强，能适应高强度的工作。 任职标准 负责移动客户端应用的功能完整性测试，界面用户体验测试，兼容性测试； 参与产品分析过程，根据产品需求创建和维护测试用例，能够制定测试计划； 分析并预警项目风险，规范测试流程和相关制度； 完成测试用例的编写，用例执行，测试报告汇总等日常测试工作，确保产品发布质量。 资深达人 任职要求 熟悉WEB技术，如DOM,HTML/Css,JavaScript； 熟练使用至少一种语言,如：Java、Python、PHP、Perl、Ruby等； 熟悉Oracle/MySQL/SQL Server等至少一种数据库管理系统，能够熟练编写SQL语句； 熟悉常见的性能测试工具或自动化测试工具,并具备测试数据的分析能力； 熟悉基于 Linux 的开发环境，可以自己开发搭建自动化测试工具有效管理自动化脚本的开发和维护工作； 能根据业务特点选型合适的框架，有工具开发或框架经验。 任职标准 能够负责项目的测试工作，依据公司制定的测试工作规范，组织并保证产品质量以及测试工作的顺利进行； 参加并完成项目的测试工作，包括功能测试和自动化测试，其主要会更多职责担当应用系统的自动化测试工作； 开发自动化测试框架，提高测试用例的自动化程度； 研究和实施先进的测试框架和测试方法，提高测试效率； 制定自动化测试计划，撰写测试文档和测试报告，保证测试质量； 协调开发与运维进度，推动项目上线； 对测试工程师进行自动化测试方面的培训岗位要求。 提高ROI 想要提高ROI（Return On Investment，投资回报率），我们必须从两方面入手：</description></item><item><title>计算机软件测试规范</title><link>https://goplscn.github.io/post/specification-of-computer-software-testing/</link><pubDate>Tue, 03 Dec 2019 22:40:33 +0000</pubDate><guid>https://goplscn.github.io/post/specification-of-computer-software-testing/</guid><description>标准号：GB/T 15532-2008 计算机软件测试规范
关联标准
GB/T 8566 信息技术 软件生存周期过程
GB/T 9386 计算机软件测试文档编制规范
GB/T 11457 信息技术 软件工程术语
GB/T 16260.1 软件工程 产品质量 第一部分：质量模型
GB/T 18492 信息技术 系统及软件完整性级别
GB/T 20158 信息技术 软件生存周期过程 配置管理
测试目的 计算机软件的测试目的是：
验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、软件需求规格说明、软件设计说明和软件产品说明等规定的软件质量要求； 通过测试，发现软件缺陷； 为软件产品的质量测量和评价提供依据。 测试类别 根据 GB/T 8566 的要求，本标准对如下测试类别做详细描述：
单元测试； 集成测试； 配置项测试（也称软件合格性测试或确认测试）； 系统测试； 验收测试。 可根据软件的模型、类型、完整性级别选择执行测试类型。
回归测试可出现在上述每个测试类别中，并贯穿于整个软件生存周期，故单独分类进行描述。
测试过程 概述 软件测试过程一般包括四项活动，按顺序分别是：测试侧或、测试设计、测试执行、测试总结。
测试策划 测试策划主要是进行测试需求分析。即确定需要测试的内容或质量特性；确定测试的充分性要求；踢出测试的基本方法；确定测试的资源和技术需求；进行风险分析与评估；制定测试计划（含资源计划和进度计划）。有关测试计划的内容和要求见 GB/T 9386 。
测试设计 依据测试需求，分析并选用已有的测试用例或设计新的测试用例；获取并验证测试数据；根据测试资源、风险等约束条件，确定测试用例执行顺序；获取测试资源，开发测试软件；建立并校准测试环境；进行测试就绪评审，主要评审测试计划的合理性和测试用例的正确性、有效性和覆盖充分性，评审测试组织、环境和设备工具是否齐备并符合要求。在进入下一阶段工作之前，应通过测试就绪评审。
测试执行 执行测试用例，获取测试结果；分析并制定测试结果。同时根据不同的判定结果采取相应的措施；对测试过程的正常或异常终止情况进行核对，并分局核对结果，对未达到测试终止条件的测试用例，决定是停止测试，还是需要修改或补充测试用例集，并进一步测试。
测试总结 整理和分析测试数据，评价测试效果和被测软件项，描述测试状态。如，实际测试与测试计划和测试说明的差异、测试充分性分析、未能解决的测试时间等；描述北侧软件项的状态，如，被测软件与需求的差异，发现的软件差错等；最后，完成软件测试报告，并通过测试评审。
测试方法 静态测试方法 静态测试方法包括检查单和静态分析方法，对文档的静态测试方法主要以检查单的形式进行，而对代码的静态测试方法一般采用代码审查、代码走查和静态分析，静态分析一般包括控制流分析、数据流分析、接口分析和表达式分析。
应对软件代码进行审查、走查或静态分析；对于规模较小、安全性要求很高的代码也可进行形式化证明。</description></item><item><title>麦肯锡教我的思考武器</title><link>https://goplscn.github.io/post/issue-driven/</link><pubDate>Sat, 28 Sep 2019 22:48:58 +0000</pubDate><guid>https://goplscn.github.io/post/issue-driven/</guid><description>议题驱动 《麦肯锡教我的思考武器——从逻辑思考到真正解决问题》
思考，不要用蛮力！工作，不只靠体力！
从议题出发，创造有价值的工作
解决问题之前，要先查明问题 提升答案的质量并不够，提升议题的质量更重要 不是知道越多越聪明，而是知道太多会变笨 与其快速做完每一件事，不如删减要做的事 与其计较数字多寡，不如计较到底有没有答案 价值矩阵 交出有价值成果的生产技术价值矩阵议题度有价值的工作解答度败者之路 以价值为导向的组织里只谈功劳不谈苦劳 对于议题度低的问题，无论多么努力拼命地挤出答案，终究也不能提高其价值，只是白忙而已 只靠努力与蛮力，不可能达到右上方有价值的工作区域 background价值矩阵低议题度-高解答度高议题度-高解答度低议题度-低解答度高议题度-低解答度解答度解答度解 &amp;#8203;答 &amp;#8203;度议题度议题度议题度有价值的工作有价值的工作低议题度-低解答度高议题度-高解答度败者之路败者之路败者之路败者之路无法产出有价值的工作高议题度-低解答度查明议题查明议题查明议题推敲解答推敲解答推敲&amp;#8203;解答</description></item><item><title>LaTeX Math Symbols</title><link>https://goplscn.github.io/post/latex-math-symbols/</link><pubDate>Sat, 28 Sep 2019 16:56:48 +0000</pubDate><guid>https://goplscn.github.io/post/latex-math-symbols/</guid><description>LaTeX 符号备忘录
Math Mode Accents LaTex Symbols \acute{a} $\acute{a}$ \bar{a} $\bar{a}$ \breve{a} $\breve{a}$ \check{a} $\check{a}$ \ddot{a} $\ddot{a}$ \dot{a} $\dot{a}$ \grave{a} $\grave{a}$ \hat{a} $\hat{a}$ \mathring{a} $\mathring{a}$ \tilde{a} $\tilde{a}$ \vec{a} $\vec{a}$ \widehat{AAA} $\widehat{AAA}$ \widetilde{AAA} $\widetilde{AAA}$ Greek Letters LaTex Symbols \alpha $\alpha$ \beta $\beta$ \gamma $\gamma$ \delta $\delta$ \epsilon $\epsilon$ \varepsilon $\varepsilon$ \zeta $\zeta$ \eta $\eta$ \Gamma $\Gamma$ \Delta $\Delta$ \Theta $\Theta$ \theta $\theta$ \vartheta $\vartheta$ \iota $\iota$ \kappa $\kappa$ \lambda $\lambda$ \mu $\mu$ \nu $\nu$ \xi $\xi$ \Lambda $\Lambda$ \Xi $\Xi$ \Pi $\Pi$ o $o$ \pi $\pi$ \varpi $\varpi$ \rho $\rho$ \varrho $\varrho$ \sigma $\sigma$ \varsigma $\varsigma$ \tau $\tau$ \Sigma $\Sigma$ \Upsilon $\Upsilon$ \Phi $\Phi$ \upsilon $\upsilon$ \phi $\phi$ \varphi $\varphi$ \chi $\chi$ \psi $\psi$ \omega $\omega$ \Psi $\Psi$ \Omega $\Omega$ Binary Relations LaTex Symbols &amp;lt; $&amp;lt;$ &amp;gt; $&amp;gt;$ = $=$ \leq $\leq$ \le $\le$ \geq $\geq$ \ge $\ge$ \equiv $\equiv$ \ll $\ll$ \gg $\gg$ \doteq $\doteq$ \prec $\prec$ \succ $\succ$ \sim $\sim$ \preceq $\preceq$ \succeq $\succeq$ \simeq $\simeq$ \subset $\subset$ \supset $\supset$ \approx $\approx$ \subseteq $\subseteq$ \supseteq $\supseteq$ \cong $\cong$ \sqsubset $\sqsubset$(Require the latexsym package) \sqsupset $\sqsupset$(Require the latexsym package) \Join $\Join$(Require the latexsym package) \sqsubseteq $\sqsubseteq$ \sqsupseteq $\sqsupseteq$ \bowtie $\bowtie$ \in $\in$ \ni $\ni$ \owns $\owns$ \propto $\propto$ \vdash $\vdash$ \dashv $\dashv$ \models $\models$ \mid $\mid$ \parallel $\parallel$ \perp $\perp$ \smile $\smile$ \frown $\frown$ \asymp $\asymp$ : $:$ \notin $\notin$ \neq $\neq$ \ne $\ne$ Binary Operators LaTex Symbols + $+$ - $-$ \pm $\pm$ \mp $\mp$ \triangleleft $\triangleleft$ \cdot $\cdot$ \div $\div$ \triangleright $\triangleright$ \times $\times$ \setminus $\setminus$ \star $\star$ \cup $\cup$ \cap $\cap$ \ast $\ast$ \sqcup $\sqcup$ \sqcap $\sqcap$ \circ $\circ$ \vee $\vee$ \lor $\lor$ \wedge $\wedge$ \land $\land$ \bullet $\bullet$ \oplus $\oplus$ \ominus $\ominus$ \diamond $\diamond$ \odot $\odot$ \oslash $\oslash$ \uplus $\uplus$ \otimes $\otimes$ \bigcirc $\bigcirc$ \amalg $\amalg$ \bigtriangleup $\bigtriangleup$ \bigtriangledown $\bigtriangledown$ \dagger $\dagger$ \lhd $\lhd$(Require the latexsym package) \rhd $\rhd$(Require the latexsym package) \ddagger $\ddagger$ \unlhd $\unlhd$(Require the latexsym package) \unrhd $\unrhd$(Require the latexsym package) \wr $\wr$ BIG Operators LaTex Symbols \sum $\sum$ \bigcup $\bigcup$ \bigvee $\bigvee$ \prod $\prod$ \bigcap $\bigcap$ \bigwedge $\bigwedge$ \coprod $\coprod$ \bigsqcup $\bigsqcup$ \biguplus $\biguplus$ \int $\int$ \oint $\oint$ \bigodot $\bigodot$ \bigoplus $\bigoplus$ \bigotimes $\bigotimes$ Arrows LaTex Symbols \leftarrow $\leftarrow$ \gets $\gets$ \longleftarrow $\longleftarrow$ \rightarrow $\rightarrow$ \to $\to$ \longrightarrow $\longrightarrow$ \leftrightarrow $\leftrightarrow$ \longleftrightarrow $\longleftrightarrow$ \Leftarrow $\Leftarrow$ \Longleftarrow $\Longleftarrow$ \Rightarrow $\Rightarrow$ \Longrightarrow $\Longrightarrow$ \Leftrightarrow $\Leftrightarrow$ \Longleftrightarrow $\Longleftrightarrow$ \mapsto $\mapsto$ \longmapsto $\longmapsto$ \hookleftarrow $\hookleftarrow$ \hookrightarrow $\hookrightarrow$ \leftharpoonup $\leftharpoonup$ \rightharpoonup $\rightharpoonup$ \leftharpoondown $\leftharpoondown$ \rightharpoondown $\rightharpoondown$ \rightleftharpoons $\rightleftharpoons$ \iff $\iff$(bigger spaces) \uparrow $\uparrow$ \downarrow $\downarrow$ \updownarrow $\updownarrow$ \Uparrow $\Uparrow$ \Downarrow $\Downarrow$ \Updownarrow $\Updownarrow$ \nearrow $\nearrow$ \searrow $\searrow$ \swarrow $\swarrow$ \nwarrow $\nwarrow$ \leadsto $\leadsto$(Require the latexsym package) Arrows as Accents LaTex Symbols \overrightarrow{AB} $\overrightarrow{AB}$ \underrightarrow{AB} $\underrightarrow{AB}$ \overleftarrow{AB} $\overleftarrow{AB}$ \underleftarrow{AB} $\underleftarrow{AB}$ \overleftrightarrow{AB} $\overleftrightarrow{AB}$ \underleftrightarrow{AB} $\underleftrightarrow{AB}$ Delimiters LaTex Symbols ( $($ ) $)$ \uparrow $\uparrow$ \lbrack $\lbrack$ [ $[$ \rbrack $\rbrack$ ] $]$ \downarrow $\downarrow$ \lbrace $\lbrace$ \{ ${$ \rbrace $\rbrace$ \} $}$ \updownarrow $\updownarrow$ \langle $\langle$ \rangle $\rangle$ \Uparrow $\Uparrow$ \vert $\vert$ | $\vert$ \Vert $\Vert$ \| $\Vert$ \Downarrow $\Downarrow$ / $/$ \backslash $\backslash$ \Updownarrow $\Updownarrow$ \lfloor $\lfloor$ \rfloor $\rfloor$ \rceil $\rceil$ \lceil $\lceil$ Large Delimiters LaTex Symbols \lgroup $\lgroup$ \rgroup $\rgroup$ \lmoustache $\lmoustache$ \arrowvert $\arrowvert$ \Arrowvert $\Arrowvert$ \bracevert $\bracevert$ \rmoustache $\rmoustache$ Miscellaneous Symbols LaTex Symbols \dots $\dots$ \cdots $\cdots$ \vdots $\vdots$ \ddots $\ddots$ \hbar $\hbar$ \imath $\imath$ \jmath $\jmath$ \ell $\ell$ \Re $\Re$ \Im $\Im$ \aleph $\aleph$ \wp $\wp$ \forall $\forall$ \exists $\exists$ \mho $\mho$(Require the latexsym package) \partial $\partial$ ' $'$ \prime $\prime$ \emptyset $\emptyset$ \infty $\infty$ \nabla $\nabla$ \triangle $\triangle$ \Box $\Box$(Require the latexsym package) \Diamond $\Diamond$(Require the latexsym package) \bot $\bot$ \top $\top$ \angle $\angle$ \surd $\surd$ \diamondsuit $\diamondsuit$ \heartsuit $\heartsuit$ \clubsuit $\clubsuit$ \spadesuit $\spadesuit$ \neg $\neg$ \lnot $\lnot$ \flat $\flat$ \natural $\natural$ \sharp $\sharp$ Non-Mathematical Symbols LaTex Symbols \dag $\dag$ \ddag $\ddag$ \S $\S$ \P $\P$ \copyright $\copyright$ \pounds $\pounds$ \textregistered $\textregistered$ \% $%$ AMS Delimiters LaTex Symbols \ulcorner $\ulcorner$ \urcorner $\urcorner$ \llcorner $\llcorner$ \lrcorner $\lrcorner$ \lvert $\lvert$ \rvert $\rvert$ \lVert $\lVert$ \rVert $\rVert$ AMS Greek and Hebrew LaTex Symbols \digamma $\digamma$ \varkappa $\varkappa$ \beth $\beth$ \gimel $\gimel$ \daleth $\daleth$ Math Alphabets Command Example Required Package \mathrm{ABCDEabcde1234} $\mathrm{ABCDEabcde1234}$ \mathit{ABCDEabcde1234} $\mathit{ABCDEabcde1234}$ \mathnormal{ABCDEabcde1234} $\mathnormal{ABCDEabcde1234}$ \mathcal{ABCDEabcde1234} $\mathcal{ABCDEabcde1234}$ \mathscr{ABCDEabcde1234} $\mathscr{ABCDEabcde1234}$ mathrsfs \mathfrak{ABCDEabcde1234} $\mathfrak{ABCDEabcde1234}$ amsfonts or amssymb \mathbb{ABCDEabcde1234} $\mathbb{ABCDEabcde1234}$ amsfonts or amssymb AMS Binary Operators LaTex Symbols \dotplus $\dotplus$ \centerdot $\centerdot$ \ltimes $\ltimes$ \rtimes $\rtimes$ \divideontimes $\divideontimes$ \doublecup $\doublecup$ \doublecap $\doublecap$ \smallsetminus $\smallsetminus$ \veebar $\veebar$ \barwedge $\barwedge$ \doublebarwedge $\doublebarwedge$ \boxplus $\boxplus$ \boxminus $\boxminus$ \circleddash $\circleddash$ \boxtimes $\boxtimes$ \boxdot $\boxdot$ \circledcirc $\circledcirc$ \intercal $\intercal$ \circledast $\circledast$ \rightthreetimes $\rightthreetimes$ \curlyvee $\curlyvee$ \curlywedge $\curlywedge$ \leftthreetimes $\leftthreetimes$ AMS Binary Relations LaTex Symbols \lessdot $\lessdot$ \gtrdot $\gtrdot$ \doteqdot $\doteqdot$ \leqslant $\leqslant$ \geqslant $\geqslant$ \risingdotseq $\risingdotseq$ \eqslantless $\eqslantless$ \eqslantgtr $\eqslantgtr$ \fallingdotseq $\fallingdotseq$ \leqq $\leqq$ \geqq $\geqq$ \eqcirc $\eqcirc$ \lll $\lll$ \llless $\llless$ \ggg $\ggg$ \circeq $\circeq$ \lesssim $\lesssim$ \gtrsim $\gtrsim$ \triangleq $\triangleq$ \lessapprox $\lessapprox$ \gtrapprox $\gtrapprox$ \bumpeq $\bumpeq$ \lessgtr $\lessgtr$ \gtrless $\gtrless$ \Bumpeq $\Bumpeq$ \lesseqgtr $\lesseqgtr$ \gtreqless $\gtreqless$ \thicksim $\thicksim$ \lesseqqgtr $\lesseqqgtr$ \gtreqqless $\gtreqqless$ \thickapprox $\thickapprox$ \preccurlyeq $\preccurlyeq$ \succcurlyeq $\succcurlyeq$ \approxeq $\approxeq$ \curlyeqprec $\curlyeqprec$ \curlyeqsucc $\curlyeqsucc$ \backsim $\backsim$ \precsim $\precsim$ \succsim $\succsim$ \backsimeq $\backsimeq$ \precapprox $\precapprox$ \succapprox $\succapprox$ \vDash $\vDash$ \subseteqq $\subseteqq$ \supseteqq $\supseteqq$ \Vdash $\Vdash$ \shortparallel $\shortparallel$ \Supset $\Supset$ \Vvdash $\Vvdash$ \blacktriangleleft $\blacktriangleleft$ \sqsupset $\sqsupset$ \backepsilon $\backepsilon$ \vartriangleright $\vartriangleright$ \because $\because$ \varpropto $\varpropto$ \blacktriangleright $\blacktriangleright$ \Subset $\Subset$ \between $\between$ \trianglerighteq $\trianglerighteq$ \smallfrown $\smallfrown$ \pitchfork $\pitchfork$ \vartriangleleft $\vartriangleleft$ \shortmid $\shortmid$ \smallsmile $\smallsmile$ \trianglelefteq $\trianglelefteq$ \therefore $\therefore$ \sqsubset $\sqsubset$ Based on The not so Short Introduction to LaTeX.</description></item><item><title>Write MathJax/LaTeX in Markdown</title><link>https://goplscn.github.io/post/write-mathjax-latex-in-markdown/</link><pubDate>Sat, 28 Sep 2019 12:19:30 +0000</pubDate><guid>https://goplscn.github.io/post/write-mathjax-latex-in-markdown/</guid><description>在markdown中编写公式如：
$$f(x)=\frac{1}{\sqrt{2 \pi \sigma x}} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$$
语法介绍 插入公式使用 $LaTeX语法表达式$ 或 $$LaTeX语法表达式$$
1求证: $2013^2 + 2013^2 \times 2014^2 + 2014^2$ 是完全平方数 求证 $2013^2 + 2013^2 \times 2014^2 + 2014^2$ 是完全平方数
1已知: 2$$\begin{cases} a + b + c = 1 \\ a^2 + b^2 + c^2 = 2 \\ a^3 + b^3 + c^3 = 3\end{cases}$$ 3求 $abc$ 的值 已知: $$\begin{cases} a + b + c = 1 \ a^2 + b^2 + c^2 = 2 \ a^3 + b^3 + c^3 = 3\end{cases}$$</description></item><item><title>CentOS 安装 Kubernetes 集群</title><link>https://goplscn.github.io/post/kubernetes-cluster-using-centos/</link><pubDate>Fri, 02 Aug 2019 20:33:54 +0000</pubDate><guid>https://goplscn.github.io/post/kubernetes-cluster-using-centos/</guid><description>准备工作 一台或多台运行着下列系统的机器: CentOS 7 RHEL 7 每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存) 2 CPU 核心或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见这里 。 开启主机上的一些特定端口. 更多详细信息请参见这里。 禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 必须 禁用交换分区。 确保每个节点上 MAC 地址和 product_uuid 的唯一性。 您可以使用下列命令获取网络接口的 MAC 地址：ip link 或是 ifconfig -a 下列命令可以用来获取 product_uuid sudo cat /sys/class/dmi/id/product_uuid 一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装失败。
检查网络适配器 如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。
检查所需端口 Master 节点 规则 方向 端口范围 作用 使用者 TCP Inbound 6443* Kubernetes API server All TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 10251 kube-scheduler Self TCP Inbound 10252 kube-controller-manager Self Worker 节点 规则 方向 端口范围 作用 使用者 TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 30000-32767 NodePort Services** All ** NodePort 服务 的默认端口范围。</description></item><item><title>pipenv 使用入门及规范</title><link>https://goplscn.github.io/post/pipenv-in-pratical/</link><pubDate>Wed, 23 Jan 2019 00:52:22 +0000</pubDate><guid>https://goplscn.github.io/post/pipenv-in-pratical/</guid><description>简介 Pipenv，它的项目简介为 Python Development Workflow for Humans，是 Python 著名的 requests 库作者 kennethreitz 写的一个包管理工具，它可以为我们的项目自动创建和管理虚拟环境并非常方便地管理 Python 包。
Pipenv我们可以简单理解为 pip 和 virtualenv 的集合体，它可以为我们的项目自动创建和管理一个虚拟环境。virtualenv 在使用时我们需要手动创建一个虚拟环境然后激活，Pipenv 会自动创建。
总的来说，Pipenv可以解决如下问题：
我们不需要再手动创建虚拟环境，Pipenv会自动为我们创建，它会在某个特定的位置创建一个 virtualenv 环境，然后调用 pipenv shell 命令切换到虚拟环境。 使用 requirements.txt 可能会导致一些问题，所以 Pipenv使用 Pipfile 和 Pipfile.lock 来替代之，而且 Pipfile 如果不存在的话会自动创建，而且在安装、升级、移除依赖包的时候会自动更新 Pipfile 和 Pipfile.lock 文件。 广泛使用 Hash 校验，保证安全性。 可以更清晰地查看 Python 包及其关系，调用 pipenv graph 即可呈现，结果简单明了。 可通过自动加载 .env 读取环境变量，简化开发流程。 安装 pip install pipenv
基本命令 1. 创建环境 pipenv 或者指定具体 python 版本 pipenv --python 3.</description></item></channel></rss>